%\usepackage{xcite}
%\externalcitedocument{bibliography}

\section{Grover's Algorithm}\label{chapGrover}
Searching through an unstructured database is a task classically achieved by exhaustively evaluating every element in the database. Assume there exists a black box (oracle) that can be asked to find out if two elements are equal. Since we're looking for a specific element in a database of size N, we'd have to query the oracle on average $\frac{N}{2}$ times, or in the worst case $N$ times.\par
Grover's algorithm, presented in \cite{grover1996}, comes as a quantum alternative to this type of problems, taking advantage of superposition by increasing desirable states' amplitudes through a process called \textit{amplitude amplification}. This method has a quadratic gain over the classical counterpart \cite{boyer1996}, being able to find a target element in expected time $\mathcal{O}(\sqrt{N})$ .\par
Let us now expand on the inner workings of the black box. We start by focusing on searching indexes     instead of directly evaluating the element and we assume $N=2^{n}$, $n$ being a positive integer. We can now define a function $f : \{0,1,...,N-1\}$ that returns $1$ when evaluating the desired (marked) element and $0$ otherwise. Since this function is to be applied to a quantum system, we must build a unitary operator $\mathcal{O}$
\begin{equation}
	\mathcal{O}\ket{x}\ket{i} = \ket{x}\ket{i\oplus f(x)} .
\end{equation}
where $\ket{x}$ is the index register, $\oplus$ is the binary sum operation and $\ket{i}$ is a qubit that is flipped if $f(x)=1$.\par 
The action of the oracle on state $\ket{0}$ will be
\begin{equation}
	\mathcal{O}\ket{x}\ket{0} = \begin{cases} \ket{x_0}\ket{1}, & \mbox{if } x = x_0 \\ \ket{x}\ket{0}, & \mbox{otherwise.} \end{cases}
\end{equation}
where $x_0$ is the marked element. More generically, $\mathcal{O}$ can be written as
\begin{equation}
	\mathcal{O}\ket{x} = (-1)^{f(x)}\ket{x} .
\end{equation}\par
This offers a bit of insight into the oracle, it \textit{marks} the solutions to the search problem by applying a phase shift to the solutions. 
%Tight bounds on quantum searching
%TODO: Decidir se meto a explicacao de complexidade aqui ou se refraseio esta parte.
The question now is, what is the procedure that determines a solution $x_0$ using $\mathcal{O}$ the minimum number of times? The answer lies in the amplitude amplification section of Grover's search, starting with the creation of a uniform superposition
\begin{equation}
	%TODO: decidir se introduzo o operador Hadamard nestas explicacoes ou se reservo para o qiskit.
	\ket{\Psi_0} = H^{\otimes n}\ket{x} = \frac{1}{\sqrt{N}}\sum_{x=0}^{N-1} \ket{x}\tab.
\end{equation}
where $H^{\otimes n}$ is the \textit{Hadamard} operator applied to an arbitrary number of states.\par
If we were to measure $\ket{x}$ at this point, the superposition would collapse to any of the base states with the same probability $\frac{1}{N} = \frac{1}{2^n}$, which means that on average, we'd need to try $N = 2^n$ times to guess the correct item. 
This is where amplitude amplification comes into effect, by means of a second unitary operator
\begin{equation}
	%TODO: Decidir se mantenho os H's.
	\mathcal{D} = (2\ket{\Psi_0}\bra{\Psi_0} - I) = H^{\otimes n}(2\ket{0}\bra{0} - I)H^{\otimes n}   
\end{equation}

This operator applies a conditional phase shift, with every computational basis state except $\ket{0}$ receiving a phase shift. This can also be described as the \textit{inversion about the mean}, for a state of arbitrary amplitudes
\begin{equation}
	\ket{\phi} = \sum_{k=0}^{N-1} \alpha_k\ket{k}
\end{equation}
the action of \mathcal{D} on state $\phi$ will be
\begin{equation}
	\mathcal{D}\ket{\phi} = \sum_{k=0}^{N-1}(-\alpha_k + 2\langle \alpha \rangle)\ket{k}
\end{equation}
where $\langle \alpha \rangle$ is the average of $\alpha_k$
\begin{equation}
	\langle \alpha \rangle = \frac{1}{N} \sum_{k=0}^{N-1} \alpha_k\ket{k}
\end{equation}
\par
The evolution operator that performs one step of the algorithm is then
\begin{equation}
	\mathcal{U} = \mathcal{D}\mathcal{O}
\end{equation}
and after $t$ steps the state of the system is
\begin{equation}
	\ket{\Psi(t)} = \mathcal{U}^t\ket{\Psi_0}.
\end{equation}\par
The optimal number of steps is, as aforementioned, proportional to $\sqrt{N}$. More precisely, if there's only one solution, maximum probability can be reached in $\frac{\pi}{4}\sqrt{N}$ iterations. In order to show that this is the case, an iteration will be formally defined here as the process that transforms the state
\begin{equation}
	\ket{\Psi(k,l)} = k\ket{i_0} + \sum_{i\neq i_0}l\ket{i}
\end{equation}
%TODO: duvida aqui com o l e o k. Tentar explicar por outras palavras.
into state $\ket{\Psi(\frac{N-2}{N}k + \frac{2(N-1)}{N}l, \frac{N-2}{N}l - \frac{2}{N}k)}$. Numbers $l$ and $k$ are real numbers that statisfy $k^2 + (N-1)l^2=1$. Running $m$ iterations over state $\ket{\Psi_0}$ will eventually lead to state $\ket{\Psi_j} = \ket{\Psi(k_j,l_j)}$ after the $j-th$ iteration, where $k_0 = l_0 = \frac{1}{\sqrt{N}}$ and
%TODO: Perceber melhor isto dos ks e js e tentar por mais diferente do bbht.
\begin{equation}
	\begin{cases}
		k_{j+1} = \frac{N-2}{N}k_j + \frac{2(N-1)}{N}l_j
		\\l_{j+1} = \frac{N-2}{N}l_j + \frac{2}{N}k_j.
	\end{cases}\label{eq:groverKandJ1}
\end{equation}
%TODO: Perceber/explicar melhor a associacao do valor de psiM com o elemento marcado.
After the last iteration, the system will be in state $\ket{\Psi_m}$ with a certain amplitude. If that amplitude corresponds to the marked element $x_0$, then it is said that the algorithm was successful.\par
\cite{grover1996} proves that there exists a value of $m < \sqrt{2N}$ such that the probability of success is at least $\frac{1}{2}$. However the probability of success does not linearly increase with the number of iterations, in fact for $m=\sqrt{2N}$ the system will succeed less that $1$ in $10$ times. \cite{boyer1996} argues that an explicit value of $m$ is needed, and it is achieved by finding a closed form formula for $k_j$ and $l_j$. The first step is to define an angle $\theta$ so that $\sin^2\theta = \frac{1}{N}$, and \ref{eq:groverKandJ1} will become
%TODO: Perceber melhor a escolha do valor the $\theta$
\begin{equation}
	\begin{cases}
		k_{j+1} = \sin{(2j+1)\theta} 
		\\l_{j+1} = \frac{1}{\sqrt{N-1}}\cos{((2j+1)\theta)}
	\end{cases}\label{eq:groverKandJ1}
\end{equation}
